//! This module provides a generic interface to the various structs that Frame generates to realize
//! name bindings.

use std::any::Any;
use std::cell::{Ref, RefCell};
use std::rc::Rc;
use std::sync::{Arc, Mutex};

/// Environments associate names (i.e. variables/parameters) with values.
///
/// Environments are defined as a trait rather than a simple HashMap so that we can directly reuse
/// the various structs generated by Frame rather than constructing a bunch of parallel data
/// structures each time we query the state of the machine.
///
/// It is common for a particular environment to be absent because there are no variables of the
/// kind held by that environment. We represent absent environments by an empty environment rather
/// than using an `Option` type because it simplifies the interface and because the distinction
/// between `None` and `Some(Empty)` is not significant.
pub trait Environment {
    /// Is this the empty environment?
    fn is_empty(&self) -> bool {
        false
    }
    /// Get the value associated with a name.
    fn lookup(&self, name: &str) -> Option<Box<dyn Any>>;
}

/// The trivial empty enviorment. This can be used in place of an environment when that environment
/// is absent.
#[derive(Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]
pub struct Empty;

impl Empty {
    /// Get an `Arc` reference to the empty environment.
    pub fn arc() -> Arc<Empty> {
        Arc::new(Empty)
    }
    /// Get an `Rc` reference to the empty environment.
    pub fn rc() -> Rc<Empty> {
        Rc::new(Empty)
    }
}

impl Environment for Empty {
    fn is_empty(&self) -> bool {
        true
    }
    fn lookup(&self, _name: &str) -> Option<Box<dyn Any>> {
        None
    }
}

impl<'a, T: Environment> Environment for Ref<'a, T> {
    fn is_empty(&self) -> bool {
        (**self).is_empty()
    }
    fn lookup(&self, name: &str) -> Option<Box<dyn Any>> {
        (**self).lookup(name)
    }
}

impl<T: Environment> Environment for RefCell<T> {
    fn is_empty(&self) -> bool {
        self.borrow().is_empty()
    }
    fn lookup(&self, name: &str) -> Option<Box<dyn Any>> {
        unsafe { (*self.as_ptr()).lookup(name) }
    }
}

impl<T: Environment + Clone> Environment for Mutex<T> {
    fn is_empty(&self) -> bool {
        self.lock().unwrap().is_empty()
    }
    fn lookup(&self, name: &str) -> Option<Box<dyn Any>> {
        // TODO: This could be super slow since it needs to clone the whole Args/Vars type...
        // Probably need to re-think the whole Environment trait to get an efficient implementation
        // for the `sync` case... :-(
        self.lock().unwrap().clone().lookup(name)
    }
}

pub mod unsync {
    pub use super::*;
    use std::rc::Rc;
    pub type EnvironmentPtr = Rc<dyn super::Environment>;
}

pub mod sync {
    pub use super::*;
    use std::sync::Arc;
    pub type EnvironmentPtr = Arc<dyn super::Environment>;
}

#[allow(clippy::approx_constant)]
#[cfg(test)]
mod tests {
    use super::*;
    use std::any::Any;

    struct TestArgs {
        x: i32,
        y: bool,
        z: Option<f32>,
    }

    impl Environment for TestArgs {
        fn lookup(&self, name: &str) -> Option<Box<dyn Any>> {
            match name {
                "x" => Some(Box::new(self.x)),
                "y" => Some(Box::new(self.y)),
                "z" => Some(Box::new(self.z)),
                _ => None,
            }
        }
    }

    #[test]
    fn empty_environment_is_empty() {
        assert!(Empty.is_empty());
    }

    #[test]
    fn empty_environment_returns_none() {
        assert!(Empty.lookup("x").is_none());
        assert!(Empty.lookup("y").is_none());
        assert!(Empty.lookup("z").is_none());
    }

    #[test]
    fn struct_environment_not_empty() {
        let args = TestArgs {
            x: 42,
            y: false,
            z: Some(3.14),
        };
        assert!(!args.is_empty());
    }

    #[test]
    fn struct_environment_lookup_success() {
        let args = TestArgs {
            x: 42,
            y: false,
            z: Some(3.14),
        };

        let opt_x = args.lookup("x");
        assert!(opt_x.is_some());
        let x = opt_x.unwrap();
        let opt_i32 = x.downcast_ref::<i32>();
        assert!(opt_i32.is_some());
        assert_eq!(*opt_i32.unwrap(), 42);

        let opt_y = args.lookup("y");
        assert!(opt_y.is_some());
        let y = opt_y.unwrap();
        let opt_bool = y.downcast_ref::<bool>();
        assert!(opt_bool.is_some());
        assert!(!*opt_bool.unwrap());

        let opt_z = args.lookup("z");
        assert!(opt_z.is_some());
        let z = opt_z.unwrap();
        let opt_bool = z.downcast_ref::<Option<f32>>();
        assert!(opt_bool.is_some());
        assert_eq!(*opt_bool.unwrap(), Some(3.14));
    }

    #[test]
    fn struct_environment_lookup_type_error() {
        let args = TestArgs {
            x: 42,
            y: false,
            z: Some(3.14),
        };
        let opt_x = args.lookup("x");
        assert!(opt_x.is_some());
        assert!(opt_x.unwrap().downcast_ref::<bool>().is_none());

        let opt_y = args.lookup("y");
        assert!(opt_y.is_some());
        assert!(opt_y.unwrap().downcast_ref::<i32>().is_none());

        let opt_z = args.lookup("z");
        assert!(opt_z.is_some());
        let z = opt_z.unwrap();
        assert!(z.downcast_ref::<f32>().is_none());
        assert!(z.downcast_ref::<Option<i32>>().is_none());
    }

    #[test]
    fn struct_environment_lookup_undefined() {
        let args = TestArgs {
            x: 42,
            y: false,
            z: Some(3.14),
        };
        assert!(args.lookup("w").is_none());
    }
}
