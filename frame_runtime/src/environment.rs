//! This module provides a generic interface to the various ways that
//! name-bindings are realized in the code generated by Frame.

use std::any::Any;

/// Environments associate names (i.e. variables/parameters) with values.
pub trait Environment {
    /// Is this environment empty?
    fn is_empty(&self) -> bool;
    /// Get the value associated with a name.
    fn lookup(&self, name: &str) -> Option<&dyn Any>;
}

/// The trivial empty environment. This can be used in place of an environment
/// when that environment is absent.
pub struct EmptyEnvironment {}

impl Environment for EmptyEnvironment {
    fn is_empty(&self) -> bool {
        true
    }
    fn lookup(&self, _name: &str) -> Option<&dyn Any> {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct TestArgs {
        x: i32,
        y: bool,
    }

    impl Environment for TestArgs {
        fn is_empty(&self) -> bool {
            false
        }
        fn lookup(&self, name: &str) -> Option<&dyn Any> {
            match name {
                "x" => Some(&self.x),
                "y" => Some(&self.y),
                _ => None,
            }
        }
    }

    #[test]
    fn empty_environment_is_empty() {
        let empty = EmptyEnvironment {};
        assert!(empty.is_empty());
    }

    #[test]
    fn empty_environment_returns_none() {
        let empty = EmptyEnvironment {};
        assert!(empty.lookup("x").is_none());
        assert!(empty.lookup("y").is_none());
    }

    #[test]
    fn struct_environment_not_empty() {
        let args = TestArgs { x: 42, y: false };
        assert!(!args.is_empty());
    }

    #[test]
    fn struct_environment_lookup_success() {
        let args = TestArgs { x: 42, y: false };

        let opt_x = args.lookup("x");
        assert!(opt_x.is_some());
        let opt_i32 = opt_x.unwrap().downcast_ref::<i32>();
        assert!(opt_i32.is_some());
        assert_eq!(*opt_i32.unwrap(), 42);

        let opt_y = args.lookup("y");
        assert!(opt_y.is_some());
        let opt_bool = opt_y.unwrap().downcast_ref::<bool>();
        assert!(opt_bool.is_some());
        assert_eq!(*opt_bool.unwrap(), false);
    }

    #[test]
    fn struct_environment_lookup_type_error() {
        let args = TestArgs { x: 42, y: false };
        let opt_x = args.lookup("x");
        assert!(opt_x.is_some());
        let opt_i32 = opt_x.unwrap().downcast_ref::<bool>();
        assert!(opt_i32.is_none());

        let opt_y = args.lookup("y");
        assert!(opt_y.is_some());
        let opt_bool = opt_y.unwrap().downcast_ref::<i32>();
        assert!(opt_bool.is_none());
    }

    #[test]
    fn struct_environment_lookup_undefined() {
        let args = TestArgs { x: 42, y: false };
        let opt_z = args.lookup("z");
        assert!(opt_z.is_none());
    }
}
