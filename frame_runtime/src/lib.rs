//! This crate provides an interface for generically inspecting and monitoring state machines
//! generated by Frame's Rust backend.
//!
//! # How to enable the runtime interface
//!
//! In order to use this interface, you must compile your Frame spec with the `runtime_support`
//! feature enabled. You can do this by adding the following line to the top of your Frame spec:
//!
//! ```text
//! #[codegen.rust.features.runtime_support:bool="true"]
//! ```
//!
//! Once your state machine has been compiled with runtime support enabled, you can use the
//! interface by including this crate in your project. For example:
//!
//! ```text
//! use frame_runtime as frame
//! ```
//!
//! # Interface overview
//!
//! This crate defines several traits and structs that enable reflecting on a running state machine:
//!
//!  * [Machine]
//!  * [State]
//!  * [Environment]
//!  * [Event]
//!  * [Transition]
//!
//! When the `runtime_support` feature is enabled, the code generated by Frame will automatically
//! implement the above traits. These traits enable determining the current state of a machine,
//! provide access to the runtime values of variables and arguments, and enable registering
//! callbacks to be notified of transitions and events.
//!
//! This crate also defines several `*Info` structs in the [info] module that provide access to
//! *static* information about a state machine. Static information is shared among all running
//! instances of a state machine, and includes things like the names and types of declared states,
//! variables, events, and actions, as well as structural information such as possible transitions
//! and the hierarchy relationships among states. Values of these structs will be automatically
//! generated and associated with the state machine. The root [MachineInfo] struct can be obtained
//! independently of a running state machine from the [Machine::machine_info()] function. For a
//! running state machine, the corresponding `*Info` struct for any element by the `info()` method
//! in the associated trait.
//!
//! Throughout this crate (and within Frame more generally), it is assumed that in any collection
//! of elements, all elements will have unique names. For example, all states within a machine will
//! have unique names, and all variables within a particular state will have unique names. This
//! constraint does not hold among all names in the machine, however. For example, a variable in
//! state `A` may have the same name as a variable in state `B`, or have the same name as a
//! parameter in state `A`.
//!
//! # Associated types and type bounds
//!
//! The [Machine] trait contains several associated types that enable the runtime interface to
//! abstract over variations in how state machines are generated by Frame, in particular, whether
//! the `thread_safe` feature is enabled or not.
//!
//! Unfortunately, since [Rust does not yet propagate trait bounds][bounds-rfc] to use sites, these
//! bounds must often be repeated anywhere that runtime interface's traits are used. For an
//! example, see the [smcat::Renderer::render_live] method, which supports rendering an arbitrary
//! running state machine in [smcat][smcat].
//!
//! # Callback interface
//!
//! When the `runtime_support` feature is enabled, each state machine has an associated
//! [EventMonitor], accessible via the [Machine::event_monitor] and [Machine::event_monitor_mut]
//! methods. The event monitor can be used to track the history of events and transitions in the
//! state machine (see the [EventMonitor] documentation), and also supports registering callbacks
//! to be notified of when an [Event] or [Transition] occurs.
//!
//! Callbacks must be wrapped in one of the structs defined in the [callback] module. There are two
//! variants corresponding to whether the state machine was compiled with the Framec feature
//! `thread_safe` set to `true` or `false`.
//!
//!  * Use [Callback] if the state machine was compiled with `thread_safe=false`.
//!  * Use [CallbackSend] if the state machine was compiled with `thread_safe=true`.
//!
//! Rust is bad at inferring the types of closure arguments, so the type of the wrapped closure
//! must be provided.
//!
//! Several examples of how to register callbacks for events and transitions are provided in the
//! integration tests for this crate. See in particular the `demo::unsync` tests for examples of
//! registering callbacks for a state machine generated with `thread_safe=false`, and the
//! `demo::sync` tests for examples for a machine with `thread_safe=true`.
//!
//! [bounds-rfc]: https://github.com/rust-lang/rust/issues/44491
//! [smcat]: https://github.com/sverweij/state-machine-cat

pub mod callback;
pub mod env;
pub mod event;
pub mod history;
pub mod info;
pub mod machine;
pub mod smcat;
pub mod transition;

pub use crate::callback::*;
pub use crate::env::*;
pub use crate::event::*;
pub use crate::history::*;
pub use crate::info::*;
pub use crate::machine::*;
pub use crate::transition::*;
